---
layout: post
title: My Blog 1
---

## 1. Create a Database

Let's first import all the packages we need, and create a database.


```python
# import relevant packages
import pandas as pd
import sqlite3
import numpy as np
# create a database in current directory called temps.db
conn = sqlite3.connect("temps.db") 
```

We will then define a helper function called prepare_df() that will get the temperature dataframe into the desired shape.


```python
# define a function to reorganize the temperature dataframe
def prepare_df(df):
    """
    This function takes in the temperature dataframe, stacks the columns by ID and Year, 
    renames the columns, converts Month into integers, and divides Temperature by 100.
    """
    df = df.set_index(keys=["ID", "Year"])
    df = df.stack()
    df = df.reset_index()
    df = df.rename(columns = {"level_2"  : "Month" , 0 : "Temp"})
    df["Month"] = df["Month"].str[5:].astype(int)
    df["Temp"]  = df["Temp"] / 100
    return(df)
```

We will then write the 3 tables into the database.


```python
# write the temperature table to the database
temps_iter = pd.read_csv("temps.csv", chunksize = 100000)
for temps in temps_iter:
    temps = prepare_df(temps)
    temps.to_sql("temperatures", conn, if_exists = "append", index = False)
```


```python
# write the station metadata to the database
url = "https://raw.githubusercontent.com/PhilChodrow/PIC16B/master/datasets/noaa-ghcn/station-metadata.csv"
stations = pd.read_csv(url)
stations.to_sql("stations", conn, if_exists = "replace", index = False)
```


```python
# write the country codes to the database
url = "https://raw.githubusercontent.com/mysociety/gaze/master/data/fips-10-4-to-iso-country-codes.csv"
countries = pd.read_csv(url)
countries.to_sql("countries", conn, if_exists = "replace", index = False)
```

    /opt/anaconda3/envs/PIC16B/lib/python3.7/site-packages/pandas/core/generic.py:2882: UserWarning: The spaces in these column names will not be changed. In pandas versions < 0.14, spaces were converted to underscores.
      method=method,


Just to make sure we have all 3 tables in the database.


```python
# check that we indeed have 3 tables in the database
cursor = conn.cursor()
cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
print(cursor.fetchall())
```

    [('temperatures',), ('stations',), ('countries',)]



```python
# close the database connection
conn.close()
```

## 2. Write a Query Function

We will create a function called query_climate_database() that allows us to get temperature readings for a specified country, in the specified date range, in the specified month of the year.


```python
# define a function called query_climate_database()
def query_climate_database(country, year_begin, year_end, month):
    """ 
    This function takes in the name of a country, the starting year, the ending year, and a month.
    It returns a Pandas dataframe of temperature readings for the specified country, 
    in the specified date range, in the specified month of the year.
    """
    # connect to the database
    conn = sqlite3.connect("temps.db") 
    cursor = conn.cursor()
    # find country code
    cursor.execute("SELECT `fips 10-4` FROM countries WHERE name='" + country + "';")
    code = cursor.fetchall()
    
    # specify searching conditions: 
    # 1) ID starts with the country code; 
    # 2) month = month in input; 
    # 3) year is between year_begin and year_end
    cond = ("S.id LIKE '" + code[0][0] + "%'" + 
        " AND T.month=" + str(month) + 
        " AND T.year BETWEEN " + str(year_begin) + 
        " AND " + str(year_end))
    
    # selecting + merging
    cmd = ("SELECT S.name, S.latitude, S.longitude, T.year, T.month, T.temp" + 
           " FROM temperatures T" + 
           " LEFT JOIN stations S ON T.id = S.id" + 
           " WHERE " + cond)
    
    # convert table to Pandas dataframe
    df = pd.read_sql_query(cmd, conn)
    # close the database connection
    conn.close()
    # add the Country column
    df.insert(3, "Country", [country]*len(df))
    # return the Pandas dataframe
    return(df)

```

For instance, if we want the temperature readings at statins in January in India between 1980~2020:


```python
df = query_climate_database("India", 1980, 2020, 1)
df.head()
```

## Write a Geographic Scatter Function for Yearly Temperature Increases

Now, let's write a geographic scatter function that shows how the average yearly change in temperature vary within a given country.
As usual, let's first import all the packages we need.


```python
# import the relevant packages
from plotly import express as px
from sklearn.linear_model import LinearRegression
import datetime
```

Let's define a helper function called coef(), which will compute the coefficient for regressing temperature on year. 


```python
def coef(data_group):
    """
    This function takes in a grouped dataframe, and computes the coefficient for regressing temperature on year. 
    """
    x = data_group[["Year"]] # 2 brackets because X should be a df
    y = data_group["Temp"]   # 1 bracket because y should be a series
    LR = LinearRegression()
    LR.fit(x, y)
    return LR.coef_[0]
```


```python
def temperature_coefficient_plot(country, year_begin, year_end, month,
                                   min_obs, **kwargs):
    """
    This function takes in:
    - a country name
    - the starting year
    - the ending year
    - a month
    - minimum # of observations
    - other keyword arguments to be passed to px.scatter_mapbox()
    
    And returns an interactive geographic scatterplot with a point for each station, 
    such that the color of the point reflects an estimate of the yearly change in temperature 
    during the specified month and time period at that station.
    """
    
    # get climate info from the database
    df = query_climate_database(country = country, 
                       year_begin = year_begin, 
                       year_end = year_end,
                       month = month)
    # close the database connection
    conn.close()
    # count how many observations each station has
    df["obs"] = df.groupby(["NAME"])["NAME"].transform('count')
    # filter out stations with observations fewer than min_obs
    df_plot = df[df["obs"] >= min_obs]
    # get rid of the Country column
    df_plot = df_plot[["NAME", "Year", "Month", "Temp", "LATITUDE", "LONGITUDE"]]
    # group stations by Name, Month, Latitude and Longitude, compute yearly changes in temperature
    df_plot = df.groupby(["NAME", "Month", "LATITUDE", "LONGITUDE"]).apply(coef)
    # reset index
    df_plot = df_plot.reset_index()
    # rename the last column
    df_plot.columns = ["NAME", "Month", "LATITUDE", "LONGITUDE", "Estimated Yearly Increase (째C)"]
    # round to 4 decimal places
    df_plot["Estimated Yearly Increase (째C)"] = round(df_plot["Estimated Yearly Increase (째C)"], 4)
    
    # plotting
    fig = px.scatter_mapbox(df_plot, 
                        lat = "LATITUDE",
                        lon = "LONGITUDE", 
                        hover_name = "NAME", 
                        color = "Estimated Yearly Increase (째C)",
                        opacity = 0.5,
                        height = 300, 
                        color_continuous_midpoint = 0, 
                        **kwargs)
    # convert month from integer to its corresponding name (e.g. 1-->January)
    month_name = datetime.datetime.strptime(str(month), "%m")
    month_name = month_name.strftime("%B")
    # set margin
    fig.update_layout(margin={"r":0,"t":80,"l":0,"b":0}, 
                      title = f"Estimates of yearly increase in temperature in {month_name} for stations in {country}, years {year_begin}~{year_end}")
    return(fig)
  
```

Plotting time!


```python
color_map = px.colors.diverging.RdGy_r # choose a colormap

fig = temperature_coefficient_plot("India", 1980, 2020, 1, 
                                   min_obs = 10,
                                   zoom = 2,
                                   mapbox_style="carto-positron",
                                   color_continuous_scale=color_map)

fig.show()
```

## 4. Two Other Graphs

### First Graph
In this graph, we will answer the question: For a given country during a specified time range, how does the average temperature vary by the longitude & latitude of the station?


```python
def avgtemp_by_location(country, year_begin, year_end, month, min_obs, **kwargs):
    """
    This function takes in:
    - a country name
    - the starting year
    - the ending year
    - a month
    - minimum # of observations
    - other keyword arguments to be passed to px.scatter_3d()
    
    And returns a 3D scatterplot showing the relationships between 
    temperature readings of stations and their longitudes & latitudes. 
    """
    df = query_climate_database(country, year_begin, year_end, month)
    # count how many observations each station has
    df["obs"] = df.groupby(["NAME"])["NAME"].transform('count')
    # filter out stations with observations fewer than min_obs
    df_plot = df[df["obs"] >= min_obs]
    # compute average temperature by station
    avg_tmp = df_plot.groupby(["NAME", "LATITUDE", "LONGITUDE", "Country"])["Temp"].apply(np.mean)
    # convert series objects to dataframes
    df_plot = avg_tmp.to_frame()
    # reset index
    df_plot = df_plot.reset_index()
    # rename the last column to "Average Temperature"
    df_plot.columns = ["NAME", "LATITUDE", "LONGITUDE", "Country", "Average Temperature"]
    # round average temperatures to 4 decimal places
    df_plot["Average Temperature"] = round(df_plot["Average Temperature"], 4)
    # convert month from integer to its corresponding name (e.g. 1-->January)
    month_name = datetime.datetime.strptime(str(month), "%m")
    month_name = month_name.strftime("%B")
    # plotting
    fig = px.scatter_3d(df_plot, 
                     x = "LATITUDE", 
                     y = "LONGITUDE", 
                        z = "Average Temperature",
                     color = "NAME",
                     hover_name = "NAME",
                     hover_data = ["Average Temperature"],
                     title = f"Average Temperatures at Stations in {country} in {month_name} by Longitude and Latitude", **kwargs)
    
    # return the plot
    return(fig)

```


```python
fig1 = avgtemp_by_location("India", 1980, 2020, 1, 
                    min_obs = 10, 
                    width = 1000,
                    height = 300,
                    opacity = 0.5)

fig1.update_layout(margin={"r":20,"t":50,"l":10,"b":0})
# show the plot
fig1.show()
```


We can see that the higher the latitude, the lower the average temperature recorded at the station. This makes sense, because higher latitude means being more remote from the equator and thus being colder. Additionally, there does not seem to be a relationship between longitude of the station and average temperature, which also makes sense because longitude measures how Eastern/Western the station is, which should have little impact on temperature.


### b) Second Graph
In this graph, we will answer the question: How are temperature readings at 3 randomly chosen stations in a country distributed during a specified time range, and how are these distributions compared to another 3 randomly chosen stations in another country?


```python
def tempdist(country1, country2, year_begin, year_end, month, min_obs, **kwargs):
    """
    This function takes in:
    - two country names
    - the starting year
    - the ending year
    - a month
    - minimum # of observations
    - other keyword arguments to be passed to px.histogram()
    
    And returns a multifaceted histogram showing the distributions of temperature readings at 6 stations
    (3 stations for each country) in the two specified countries during a given time period. 
    """
    df1 = query_climate_database(country1, year_begin, year_end, month)
    df2 = query_climate_database(country2, year_begin, year_end, month)
    # count how many observations each station has
    df1["obs"] = df1.groupby(["NAME"])["NAME"].transform('count')
    df2["obs"] = df2.groupby(["NAME"])["NAME"].transform('count')
    # filter out stations with observations fewer than min_obs
    df1_plot = df1[df1["obs"] >= min_obs]
    df2_plot = df2[df2["obs"] >= min_obs]
    # get lists of stations
    stations1 = df1_plot.NAME.unique()
    stations2 = df2_plot.NAME.unique()
    # randomly choose 3 stations from each country
    stations1 = stations1[np.random.randint(low=1, high=len(stations1), size=(3, 1))].squeeze()
    stations2 = stations2[np.random.randint(low=1, high=len(stations2), size=(3, 1))].squeeze()
    # select rows that contain info for the 3 stations
    df1_plot = df1_plot[df1_plot["NAME"].isin(stations1)]
    df2_plot = df2_plot[df2_plot["NAME"].isin(stations2)]
    # concatenate the two dataframes
    df_plot = pd.concat([df1_plot, df2_plot])
    # convert month from integer to its corresponding name (e.g. 1-->January)
    month_name = datetime.datetime.strptime(str(month), "%m")
    month_name = month_name.strftime("%B")
    # plotting    
    fig = px.histogram(df_plot, 
                       x = "Temp", 
                       color = "NAME",
                       barmode='stack',
                      facet_col = "Country", 
                       title = f"Temperatures in {month_name} between {year_begin} and {year_end} at 6 stations in {country1} and {country2}",
                       **kwargs)
    return(fig)
```


```python
fig2 = tempdist("India", "Algeria", 1980, 2020, 1, 
               min_obs = 10, nbins = 30, width = 1000, height = 300, opacity = 0.5)
# reduce whitespace
fig2.update_layout(margin={"r":0,"t":50,"l":0,"b":0})
# show the plot
fig2.show()
```
